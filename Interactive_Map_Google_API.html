<!DOCTYPE html>
<html>
<head>
    <title>New York Map with Google Maps</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #map {
            height: 600px;
            width: 800px;
            position: relative;
        }
        #map.fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 9000;
            margin: 0 !important;
            padding: 0 !important;
        }
        .overlay {
            position: absolute;
            pointer-events: none;
        }
        .neighborhood {
            fill-opacity: 0.4;
            stroke: white;
            stroke-width: 1px;
            pointer-events: all !important;
            cursor: pointer;
            vector-effect: non-scaling-stroke;
        }
        .neighborhood:hover {
            fill-opacity: 0.7;
            stroke-width: 2px;
        }
        #fixed-tooltip {
            position: fixed;
            z-index: 100000;
            background: white;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            font-size: 14px;
            max-width: 300px;
            line-height: 1.4;
        }
        #fixed-tooltip strong {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-size: 15px;
        }
        .tooltip-health {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
            color: #666;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 9999;
        }
    </style>
</head>
<body>
    <h2>New York City Neighborhoods</h2>
    <div id="map"></div>
    <div id="fixed-tooltip" style="display: none;"></div>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <script>
        // Add document-level event listeners
        document.addEventListener('mousemove', function(e) {
            const target = e.target;
            if (target.tagName === 'path' && target.classList.contains('neighborhood')) {
                const tooltip = document.getElementById('fixed-tooltip');
                if (!tooltip) return;

                const properties = JSON.parse(target.getAttribute('data-feature'));
                
                const content = `
                    <strong>${properties.NTAName}</strong>
                    <div>${properties.BoroName}</div>
                    <div>Census Track: ${properties.CTLabel}</div>
                    <div class="tooltip-health">
                        <strong>Mean Tree Health:</strong> ${
                            typeof properties.meanHealth === 'number' 
                                ? properties.meanHealth.toFixed(2) 
                                : properties.meanHealth
                        }
                    </div>
                `;
                
                tooltip.innerHTML = content;
                tooltip.style.display = 'block';

                let left = e.clientX + 10;
                let top = e.clientY + 10;

                const tooltipRect = tooltip.getBoundingClientRect();

                if (left + tooltipRect.width > window.innerWidth) {
                    left = e.clientX - tooltipRect.width - 10;
                }
                if (top + tooltipRect.height > window.innerHeight) {
                    top = e.clientY - tooltipRect.height - 10;
                }

                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
            }
        });

        document.addEventListener('mouseout', function(e) {
            if (e.target.tagName === 'path' && e.target.classList.contains('neighborhood')) {
                const tooltip = document.getElementById('fixed-tooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            }
        });

        function loadGoogleMaps() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyBk7SlPBT8xcER27B6VahMdKtJ2a_qGXnM&loading=async&callback=initMap`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        function initMap() {
            let overlay;
            const map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 40.7128, lng: -74.006 },
                zoom: 11,
                styles: [{
                    featureType: 'administrative.neighborhood',
                    elementType: 'labels',
                    stylers: [{ visibility: 'off' }]
                }],
                fullscreenControl: true,
                mapTypeControl: true,
                streetViewControl: true,
                zoomControl: true
            });

            google.maps.event.addListener(map, 'fullscreenChanged', () => {
                const mapDiv = document.getElementById('map');
                if (document.fullscreenElement) {
                    mapDiv.classList.add('fullscreen');
                } else {
                    mapDiv.classList.remove('fullscreen');
                }
                if (overlay) {
                    overlay.draw();
                }
            });
            class NeighborhoodOverlay extends google.maps.OverlayView {
                constructor(data, healthData) {
                    super();
                    this.data = data;
                    this.healthData = healthData;
                    this.drawRequested = false;
                }

                onAdd() {
                    // Create overlay container
                    this.layer = d3.select(this.getPanes().overlayMouseTarget)
                        .append("div")
                        .attr("class", "overlay");

                    // Create SVG element
                    this.svg = this.layer.append("svg")
                        .style("position", "absolute")
                        .style("pointer-events", "auto");

                    // Initialize features with health data
                    this.features = topojson.feature(
                        this.data, 
                        this.data.objects.nyct2010reproj
                    ).features;

                    // Merge health data with features
                    this.features.forEach(feature => {
                        const tract = feature.properties.CTLabel.trim();
                        const borough = feature.properties.BoroName.trim();
                        const key = tract + '_' + borough;
                        feature.properties.meanHealth = this.healthData[key] || 'No data';
                    });

                    this.draw();
                }

                draw() {
                    const projection = this.getProjection();
                    if (!projection) return;

                    const bounds = map.getBounds();
                    const sw = bounds.getSouthWest();
                    const ne = bounds.getNorthEast();
                    const swPixel = projection.fromLatLngToDivPixel(sw);
                    const nePixel = projection.fromLatLngToDivPixel(ne);

                    // Set container size and position
                    this.layer
                        .style("left", swPixel.x + "px")
                        .style("top", nePixel.y + "px")
                        .style("width", (nePixel.x - swPixel.x) + "px")
                        .style("height", (swPixel.y - nePixel.y) + "px");

                    this.svg
                        .style("width", "100%")
                        .style("height", "100%");

                    const transform = {
                        point: (function(projection, swPixel, nePixel) {
                            return function(x, y) {
                                const latLng = new google.maps.LatLng(y, x);
                                const pixel = projection.fromLatLngToDivPixel(latLng);
                                this.stream.point(pixel.x - swPixel.x, pixel.y - nePixel.y);
                            };
                        })(projection, swPixel, nePixel)
                    };

                    const path = d3.geoPath().projection(d3.geoTransform(transform));

                    const boroughColors = {
                        "Manhattan": "#1f77b4",
                        "Brooklyn": "#2ca02c",
                        "Queens": "#ff7f0e",
                        "Bronx": "#d62728",
                        "Staten Island": "#9467bd"
                    };

                    // Update paths
                    const paths = this.svg.selectAll("path")
                        .data(this.features);

                    // Remove old paths
                    paths.exit().remove();

                    // Add new paths
                    const enter = paths.enter()
                        .append("path")
                        .attr("class", "neighborhood");

                    // Update all paths
                    enter.merge(paths)
                        .attr("d", path)
                        .style("fill", d => boroughColors[d.properties.BoroName])
                        .style("pointer-events", "all")
                        .each(function(d) {
                            // Store the feature data as a data attribute
                            d3.select(this).attr('data-feature', JSON.stringify(d.properties));
                        });
                }

                onRemove() {
                    if (this.layer) {
                        this.layer.remove();
                    }
                }
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.textContent = 'Loading data...';
            map.getDiv().appendChild(loadingDiv);

            // Load both datasets
            Promise.all([
                d3.json("nyct2010.json"),
                d3.csv("Trees_Quantified.csv")
            ]).then(([data, csvData]) => {
                console.log("Data loaded successfully");
                
                // Clean up and process CSV data
                csvData.forEach(d => {
                    d['census tract'] = d['census tract'].trim();
                    d.health = +d.health;
                });

                // Create health data mapping
                const healthDataMap = d3.nest()
                    .key(d => d['census tract'] + '_' + d['borough'])
                    .rollup(leaves => {
                        return d3.mean(leaves, d => d.health);
                    })
                    .object(csvData);

                // Remove loading indicator
                loadingDiv.remove();

                // Create overlay with both datasets
                overlay = new NeighborhoodOverlay(data, healthDataMap);
                overlay.setMap(map);

                // Add listener for bounds changes
                let timeout;
                google.maps.event.addListener(map, 'bounds_changed', () => {
                    if (timeout) clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        overlay.draw();
                    }, 50);
                });
            })
            .catch(error => {
                console.error("Error loading data:", error);
                loadingDiv.textContent = 'Error loading data. Please try again.';
                setTimeout(() => loadingDiv.remove(), 3000);
            });
        }

        window.initMap = initMap;
        loadGoogleMaps();
    </script>
</body>
</html>